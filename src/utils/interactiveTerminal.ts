import chalk from 'chalk';
import inquirer from 'inquirer';
import { logger } from './logger';
import { getRedisClient } from '@/config/redis';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

interface LogEntry {
  timestamp: string;
  level: 'info' | 'error' | 'warn' | 'debug';
  message: string;
}

class InteractiveTerminal {
  private logs: LogEntry[] = [];
  private isRunning = true;

  constructor() {
    this.setupLogCapture();
  }

  private setupLogCapture() {
    // Capturar logs do sistema
    const originalLog = console.log;
    const originalError = console.error;
    const originalWarn = console.warn;

    console.log = (...args) => {
      this.addLog('info', args.join(' '));
      originalLog(...args);
    };

    console.error = (...args) => {
      this.addLog('error', args.join(' '));
      originalError(...args);
    };

    console.warn = (...args) => {
      this.addLog('warn', args.join(' '));
      originalWarn(...args);
    };
  }

  private addLog(level: LogEntry['level'], message: string) {
    this.logs.push({
      timestamp: new Date().toISOString(),
      level,
      message
    });

    // Manter apenas os √∫ltimos 100 logs
    if (this.logs.length > 100) {
      this.logs.shift();
    }
  }

  private clearScreen() {
    console.clear();
  }

  private showHeader() {
    console.log(chalk.blue.bold('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó'));
    console.log(chalk.blue.bold('‚ïë                    S2Mangas Dev Terminal                    ‚ïë'));
    console.log(chalk.blue.bold('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù'));
    console.log();
  }

  private async showMenu() {
    const choices = [
      { name: 'üìä Status do Sistema', value: 'status' },
      { name: 'üìù Visualizar Logs', value: 'logs' },
      { name: 'üóëÔ∏è  Limpar Logs', value: 'clear-logs' },
      { name: 'üîÑ Reload do Servidor', value: 'reload' },
      { name: 'üóÑÔ∏è  Status do Redis', value: 'redis' },
      { name: 'üß™ Testes R√°pidos', value: 'tests' },
      { name: 'üìÅ Abrir no VS Code', value: 'vscode' },
      { name: 'üåê Abrir no Navegador', value: 'browser' },
      { name: 'üìö Documenta√ß√£o', value: 'docs' },
      { name: '‚ùå Sair', value: 'exit' }
    ];

    const { action } = await inquirer.prompt([
      {
        type: 'list',
        name: 'action',
        message: 'Escolha uma op√ß√£o:',
        choices,
        pageSize: 10
      }
    ]);

    return action;
  }

  private async showSystemStatus() {
    this.clearScreen();
    this.showHeader();
    
    console.log(chalk.yellow.bold('üìä Status do Sistema:'));
    console.log();

    // Status do Redis
    try {
      const redisClient = getRedisClient();
      if (redisClient) {
        const ping = await redisClient.ping();
        console.log(chalk.green('‚úÖ Redis: Conectado') + ` (${ping})`);
      } else {
        console.log(chalk.red('‚ùå Redis: N√£o conectado'));
      }
    } catch (error: any) {
      console.log(chalk.red('‚ùå Redis: Erro na conex√£o'));
    }

    // Status das vari√°veis de ambiente
    console.log();
    console.log(chalk.yellow.bold('üîß Vari√°veis de Ambiente:'));
    console.log(`NODE_ENV: ${chalk.cyan(process.env.NODE_ENV || 'development')}`);
    console.log(`PORT: ${chalk.cyan(process.env.PORT || '3000')}`);
    console.log(`REDIS_URL: ${chalk.cyan(process.env.REDIS_URL ? 'Configurado' : 'N√£o configurado')}`);
    console.log(`REDIS_PUBLIC_URL: ${chalk.cyan(process.env.REDIS_PUBLIC_URL ? 'Configurado' : 'N√£o configurado')}`);
    console.log(`DATABASE_URL: ${chalk.cyan(process.env.DATABASE_URL ? 'Configurado' : 'N√£o configurado')}`);

    // Uptime
    console.log();
    console.log(chalk.yellow.bold('‚è±Ô∏è  Informa√ß√µes:'));
    console.log(`Uptime: ${chalk.cyan(this.formatUptime(process.uptime()))}`);
    console.log(`Mem√≥ria: ${chalk.cyan(this.formatMemoryUsage())}`);
    console.log(`PID: ${chalk.cyan(process.pid)}`);

    await this.waitForEnter();
  }

  private async showLogs() {
    this.clearScreen();
    this.showHeader();
    
    console.log(chalk.yellow.bold('üìù Logs Recentes:'));
    console.log();

    const recentLogs = this.logs.slice(-20);
    
    if (recentLogs.length === 0) {
      console.log(chalk.gray('Nenhum log dispon√≠vel'));
    } else {
      recentLogs.forEach(log => {
        const time = new Date(log.timestamp).toLocaleTimeString();
        const levelColor = this.getLevelColor(log.level);
        const levelText = this.getLevelText(log.level);
        
        console.log(`${chalk.gray(time)} ${levelColor(levelText)} ${log.message}`);
      });
    }

    console.log();
    console.log(chalk.gray(`Mostrando ${recentLogs.length} de ${this.logs.length} logs`));
    await this.waitForEnter();
  }

  private async clearLogs() {
    this.logs = [];
    console.log(chalk.green('‚úÖ Logs limpos com sucesso!'));
    await this.waitForEnter();
  }

  private async reloadServer() {
    console.log(chalk.yellow('üîÑ Reiniciando servidor...'));
    console.log(chalk.gray('Pressione Ctrl+C para parar o processo atual'));
    console.log(chalk.gray('Em seguida, execute: npm run dev'));
    await this.waitForEnter();
  }

  private async showRedisStatus() {
    this.clearScreen();
    this.showHeader();
    
    console.log(chalk.yellow.bold('üóÑÔ∏è  Status do Redis:'));
    console.log();

    try {
      const redisClient = getRedisClient();
      if (!redisClient) {
        console.log(chalk.red('‚ùå Cliente Redis n√£o dispon√≠vel'));
        await this.waitForEnter();
        return;
      }

      // Teste de conex√£o
      const ping = await redisClient.ping();
      console.log(chalk.green(`‚úÖ Ping: ${ping}`));

      // Informa√ß√µes do servidor
      const info = await redisClient.info();
      const lines = info.split('\n');
      
      console.log();
      console.log(chalk.yellow.bold('üìä Informa√ß√µes do Servidor:'));
      
      const relevantInfo = [
        'redis_version',
        'connected_clients',
        'used_memory_human',
        'uptime_in_seconds',
        'total_commands_processed'
      ];

      lines.forEach(line => {
        const [key, value] = line.split(':');
        if (relevantInfo.includes(key)) {
          console.log(`${chalk.cyan(key)}: ${chalk.white(value)}`);
        }
      });

      // Teste de opera√ß√µes b√°sicas
      console.log();
      console.log(chalk.yellow.bold('üß™ Teste de Opera√ß√µes:'));
      
      await redisClient.set('test_key', 'test_value');
      const value = await redisClient.get('test_key');
      await redisClient.del('test_key');
      
      console.log(chalk.green('‚úÖ Set/Get/Delete: Funcionando'));

    } catch (error: any) {
      console.log(chalk.red(`‚ùå Erro: ${error.message}`));
    }

    await this.waitForEnter();
  }

  private async runQuickTests() {
    this.clearScreen();
    this.showHeader();
    
    console.log(chalk.yellow.bold('üß™ Testes R√°pidos:'));
    console.log();

    const tests = [
      { name: 'Redis Connection', fn: this.testRedis },
      { name: 'Environment Variables', fn: this.testEnvVars },
      { name: 'File System', fn: this.testFileSystem },
      { name: 'Network', fn: this.testNetwork }
    ];

    for (const test of tests) {
      try {
        console.log(`üîç Testando: ${test.name}...`);
        await test.fn();
        console.log(chalk.green(`‚úÖ ${test.name}: OK`));
      } catch (error: any) {
        console.log(chalk.red(`‚ùå ${test.name}: ${error.message}`));
      }
      console.log();
    }

    await this.waitForEnter();
  }

  private async testRedis() {
    const redisClient = getRedisClient();
    if (!redisClient) throw new Error('Cliente n√£o dispon√≠vel');
    await redisClient.ping();
  }

  private testEnvVars() {
    const required = ['DATABASE_URL', 'JWT_SECRET'];
    const missing = required.filter(key => !process.env[key]);
    if (missing.length > 0) {
      throw new Error(`Vari√°veis faltando: ${missing.join(', ')}`);
    }
  }

  private async testFileSystem() {
    const fs = require('fs').promises;
    await fs.access('./src');
  }

  private async testNetwork() {
    const { default: axios } = await import('axios');
    await axios.get('http://localhost:3000/health', { timeout: 5000 });
  }

  private async openInVSCode() {
    try {
      await execAsync('code .');
      console.log(chalk.green('‚úÖ VS Code aberto!'));
    } catch (error) {
      console.log(chalk.red('‚ùå Erro ao abrir VS Code'));
    }
    await this.waitForEnter();
  }

  private async openInBrowser() {
    const port = process.env.PORT || 3000;
    const url = `http://localhost:${port}`;
    
    try {
      await execAsync(`open ${url}`);
      console.log(chalk.green(`‚úÖ Navegador aberto em ${url}`));
    } catch (error) {
      console.log(chalk.red('‚ùå Erro ao abrir navegador'));
      console.log(chalk.cyan(`Acesse manualmente: ${url}`));
    }
    await this.waitForEnter();
  }

  private async showDocumentation() {
    this.clearScreen();
    this.showHeader();
    
    console.log(chalk.yellow.bold('üìö Documenta√ß√£o:'));
    console.log();
    console.log(chalk.cyan('üîó Endpoints:'));
    console.log('  ‚Ä¢ Health: /health');
    console.log('  ‚Ä¢ API Docs: /docs');
    console.log('  ‚Ä¢ Metrics: /metrics');
    console.log();
    console.log(chalk.cyan('üìÅ Estrutura:'));
    console.log('  ‚Ä¢ src/modules/ - M√≥dulos da aplica√ß√£o');
    console.log('  ‚Ä¢ src/config/ - Configura√ß√µes');
    console.log('  ‚Ä¢ src/middlewares/ - Middlewares');
    console.log('  ‚Ä¢ docs/ - Documenta√ß√£o t√©cnica');
    console.log();
    console.log(chalk.cyan('üõ†Ô∏è  Comandos √öteis:'));
    console.log('  ‚Ä¢ npm run dev - Desenvolvimento');
    console.log('  ‚Ä¢ npm run build - Build de produ√ß√£o');
    console.log('  ‚Ä¢ npm run test - Executar testes');
    console.log('  ‚Ä¢ npm run studio - Prisma Studio');

    await this.waitForEnter();
  }

  private getLevelColor(level: LogEntry['level']) {
    switch (level) {
      case 'error': return chalk.red;
      case 'warn': return chalk.yellow;
      case 'info': return chalk.blue;
      case 'debug': return chalk.gray;
      default: return chalk.white;
    }
  }

  private getLevelText(level: LogEntry['level']) {
    switch (level) {
      case 'error': return 'ERROR';
      case 'warn': return 'WARN ';
      case 'info': return 'INFO ';
      case 'debug': return 'DEBUG';
      default: return 'LOG  ';
    }
  }

  private formatUptime(seconds: number): string {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    return `${hours}h ${minutes}m ${secs}s`;
  }

  private formatMemoryUsage(): string {
    const usage = process.memoryUsage();
    const mb = (bytes: number) => Math.round(bytes / 1024 / 1024 * 100) / 100;
    return `${mb(usage.heapUsed)}MB / ${mb(usage.heapTotal)}MB`;
  }

  private async waitForEnter() {
    console.log();
    await inquirer.prompt([
      {
        type: 'input',
        name: 'continue',
        message: 'Pressione Enter para continuar...',
        default: ''
      }
    ]);
  }

  public async start() {
    while (this.isRunning) {
      this.clearScreen();
      this.showHeader();

      const action = await this.showMenu();

      switch (action) {
        case 'status':
          await this.showSystemStatus();
          break;
        case 'logs':
          await this.showLogs();
          break;
        case 'clear-logs':
          await this.clearLogs();
          break;
        case 'reload':
          await this.reloadServer();
          break;
        case 'redis':
          await this.showRedisStatus();
          break;
        case 'tests':
          await this.runQuickTests();
          break;
        case 'vscode':
          await this.openInVSCode();
          break;
        case 'browser':
          await this.openInBrowser();
          break;
        case 'docs':
          await this.showDocumentation();
          break;
        case 'exit':
          this.isRunning = false;
          console.log(chalk.green('üëã At√© logo!'));
          process.exit(0);
          break;
      }
    }
  }
}

export const startInteractiveTerminal = () => {
  const terminal = new InteractiveTerminal();
  terminal.start();
};
