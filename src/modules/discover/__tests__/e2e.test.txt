import { jest } from '@jest/globals';
import request from 'supertest';
import express from 'express';
import { DiscoverRouter } from '../DiscoverRouter';
import * as discoverController from '../DiscoverController';
import * as discoverHandler from '../DiscoverHandler';

// Configuração dos mocks
jest.mock('../DiscoverController');
jest.mock('../DiscoverHandler');
jest.mock('@/middlewares/auth', () => ({
  requireAuth: jest.fn((req: any, res: any, next: any) => {
    req.user = { id: 'user-123' };
    next();
  }),
}));

jest.mock('@/middlewares/smartCache', () => ({
  smartCacheMiddleware: jest.fn(() => (req: any, res: any, next: any) => next()),
}));

jest.mock('@/utils/pagination', () => ({
  getPaginationParams: jest.fn(() => ({ page: 1, take: 10, skip: 0 })),
}));

jest.mock('@/utils/zodError', () => ({
  handleZodError: jest.fn((error: any, res: any) => {
    res.status(500).json({ error: error.message });
  }),
}));

const mockedController = discoverController as jest.Mocked<typeof discoverController>;
const mockedHandler = discoverHandler as jest.Mocked<typeof discoverHandler>;

describe('Discover Module - Testes de Integração', () => {
  let app: express.Application;

  beforeEach(() => {
    app = express();
    app.use(express.json());
    app.use('/discover', DiscoverRouter);
    jest.clearAllMocks();
  });

  describe('Fluxo Completo - Recents', () => {
    it('deve executar o fluxo completo para mangás recentes', async () => {
      const mockHandlerResponse = {
        data: [
          {
            id: 'manga-1',
            manga_uuid: 'uuid-1',
            title: 'Manga Recente 1',
            description: 'Descrição do manga recente 1',
            cover: 'cover1.jpg',
            views_count: 100
          }
        ],
        pagination: {
          total: 1,
          page: 1,
          limit: 10,
          totalPages: 1,
          next: false,
          prev: false
        }
      };

      mockedHandler.getRecent.mockResolvedValue(mockHandlerResponse);
      mockedController.getRecent.mockImplementation(async (req: any, res: any) => {
        const result = await discoverHandler.getRecent('pt', 1, 10);
        res.status(200).json(result);
      });

      const response = await request(app)
        .get('/discover/recents?lg=pt&page=1&take=10')
        .expect(200);

      expect(response.body).toEqual(mockHandlerResponse);
      expect(mockedController.getRecent).toHaveBeenCalled();
    });

    it('deve tratar erro no fluxo de recents', async () => {
      mockedHandler.getRecent.mockRejectedValue(new Error('Erro no banco de dados'));
      mockedController.getRecent.mockImplementation(async (req: any, res: any) => {
        try {
          await discoverHandler.getRecent('pt', 1, 10);
        } catch (error: any) {
          res.status(500).json({ error: error.message });
        }
      });

      const response = await request(app)
        .get('/discover/recents')
        .expect(500);

      expect(response.body).toEqual({ error: 'Erro no banco de dados' });
    });
  });

  describe('Fluxo Completo - Most Viewed', () => {
    it('deve executar o fluxo completo para mangás mais vistos', async () => {
      const mockHandlerResponse = {
        data: [
          {
            id: 'manga-1',
            manga_uuid: 'uuid-1',
            title: 'Manga Mais Visto',
            description: 'Descrição do manga mais visto',
            cover: 'cover1.jpg',
            views_count: 1000
          }
        ],
        pagination: {
          total: 1,
          page: 1,
          limit: 10,
          totalPages: 1,
          next: false,
          prev: false
        }
      };

      mockedHandler.getMostViewed.mockResolvedValue(mockHandlerResponse);
      mockedController.getMostViewed.mockImplementation(async (req: any, res: any) => {
        const result = await discoverHandler.getMostViewed('pt', 1, 10);
        res.status(200).json(result);
      });

      const response = await request(app)
        .get('/discover/views?lg=pt')
        .expect(200);

      expect(response.body).toEqual(mockHandlerResponse);
      expect(mockedController.getMostViewed).toHaveBeenCalled();
    });
  });

  describe('Fluxo Completo - Most Liked', () => {
    it('deve executar o fluxo completo para mangás mais curtidos', async () => {
      const mockHandlerResponse = {
        data: [
          {
            id: 'manga-1',
            manga_uuid: 'uuid-1',
            title: 'Manga Mais Curtido',
            description: 'Descrição do manga mais curtido',
            cover: 'cover1.jpg',
            likes_count: 500
          }
        ],
        pagination: {
          total: 1,
          page: 1,
          limit: 10,
          totalPages: 1,
          next: false,
          prev: false
        }
      };

      mockedHandler.getMostLiked.mockResolvedValue(mockHandlerResponse);
      mockedController.getMostLiked.mockImplementation(async (req: any, res: any) => {
        const result = await discoverHandler.getMostLiked('pt', 1, 10);
        res.status(200).json(result);
      });

      const response = await request(app)
        .get('/discover/likes?lg=pt')
        .expect(200);

      expect(response.body).toEqual(mockHandlerResponse);
      expect(mockedController.getMostLiked).toHaveBeenCalled();
    });
  });

  describe('Fluxo Completo - Feed', () => {
    it('deve executar o fluxo completo para feed personalizado', async () => {
      const mockHandlerResponse = {
        data: [
          {
            id: 'manga-1',
            manga_uuid: 'uuid-1',
            title: 'Manga do Feed',
            description: 'Descrição do manga do feed',
            cover: 'cover1.jpg'
          }
        ],
        pagination: {
          total: 1,
          page: 1,
          limit: 10,
          totalPages: 1,
          next: false,
          prev: false
        }
      };

      mockedHandler.getFeed.mockResolvedValue(mockHandlerResponse);
      mockedController.getFeed.mockImplementation(async (req: any, res: any) => {
        const userId = req.user?.id;
        if (!userId) {
          return res.status(401).json({ error: 'Não autenticado.' });
        }
        const result = await discoverHandler.getFeed(userId, 'pt', 1, 10);
        res.status(200).json(result);
      });

      const response = await request(app)
        .get('/discover/feed?lg=pt')
        .expect(200);

      expect(response.body).toEqual(mockHandlerResponse);
      expect(mockedController.getFeed).toHaveBeenCalled();
    });

    it('deve retornar erro 401 para usuário não autenticado no feed', async () => {
      // Mock do middleware de auth que falha
      const { requireAuth } = require('@/middlewares/auth');
      requireAuth.mockImplementation((req: any, res: any, next: any) => {
        res.status(401).json({ error: 'Não autenticado.' });
      });

      const response = await request(app)
        .get('/discover/feed')
        .expect(401);

      expect(response.body).toEqual({ error: 'Não autenticado.' });
    });
  });

  describe('Fluxo Completo - IA', () => {
    it('deve executar o fluxo completo para recomendações de IA', async () => {
      const mockHandlerResponse = {
        data: [
          {
            id: 'manga-1',
            manga_uuid: 'uuid-1',
            title: 'Recomendação IA',
            description: 'Descrição da recomendação por IA',
            cover: 'cover1.jpg'
          }
        ],
        pagination: {
          total: 1,
          page: 1,
          limit: 10,
          totalPages: 1,
          next: false,
          prev: false
        }
      };

      mockedHandler.getIA.mockResolvedValue(mockHandlerResponse);
      mockedController.getIA.mockImplementation(async (req: any, res: any) => {
        const userId = req.user?.id;
        if (!userId) {
          return res.status(401).json({ error: 'Não autenticado.' });
        }
        const result = await discoverHandler.getIA(userId, 'pt', 1, 10);
        res.status(200).json(result);
      });

      const response = await request(app)
        .get('/discover/ia?lg=pt')
        .expect(200);

      expect(response.body).toEqual(mockHandlerResponse);
      expect(mockedController.getIA).toHaveBeenCalled();
    });
  });

  describe('Testes de Middleware', () => {
    it('deve aplicar middleware de cache em todas as rotas', async () => {
      const { smartCacheMiddleware } = require('@/middlewares/smartCache');
      
      // Simula responses dos controllers
      mockedController.getRecent.mockImplementation((req: any, res: any) => {
        res.status(200).json({ data: [], pagination: {} });
      });
      mockedController.getMostViewed.mockImplementation((req: any, res: any) => {
        res.status(200).json({ data: [], pagination: {} });
      });
      mockedController.getMostLiked.mockImplementation((req: any, res: any) => {
        res.status(200).json({ data: [], pagination: {} });
      });
      mockedController.getFeed.mockImplementation((req: any, res: any) => {
        res.status(200).json({ data: [], pagination: {} });
      });
      mockedController.getIA.mockImplementation((req: any, res: any) => {
        res.status(200).json({ data: [], pagination: {} });
      });

      // Testa todas as rotas
      await request(app).get('/discover/recents').expect(200);
      await request(app).get('/discover/views').expect(200);
      await request(app).get('/discover/likes').expect(200);
      await request(app).get('/discover/feed').expect(200);
      await request(app).get('/discover/ia').expect(200);

      // Verifica se o middleware foi chamado
      expect(smartCacheMiddleware).toHaveBeenCalledTimes(5);
    });

    it('deve aplicar middleware de autenticação em todas as rotas', async () => {
      const { requireAuth } = require('@/middlewares/auth');
      
      // Simula responses dos controllers
      mockedController.getRecent.mockImplementation((req: any, res: any) => {
        res.status(200).json({ data: [], pagination: {} });
      });
      mockedController.getMostViewed.mockImplementation((req: any, res: any) => {
        res.status(200).json({ data: [], pagination: {} });
      });
      mockedController.getMostLiked.mockImplementation((req: any, res: any) => {
        res.status(200).json({ data: [], pagination: {} });
      });
      mockedController.getFeed.mockImplementation((req: any, res: any) => {
        res.status(200).json({ data: [], pagination: {} });
      });
      mockedController.getIA.mockImplementation((req: any, res: any) => {
        res.status(200).json({ data: [], pagination: {} });
      });

      // Testa todas as rotas
      await request(app).get('/discover/recents').expect(200);
      await request(app).get('/discover/views').expect(200);
      await request(app).get('/discover/likes').expect(200);
      await request(app).get('/discover/feed').expect(200);
      await request(app).get('/discover/ia').expect(200);

      // Verifica se o middleware foi chamado
      expect(requireAuth).toHaveBeenCalledTimes(5);
    });
  });

  describe('Testes de Configuração de Cache', () => {
    it('deve aplicar configuração de cache específica para feed', async () => {
      const { smartCacheMiddleware } = require('@/middlewares/smartCache');
      
      mockedController.getFeed.mockImplementation((req: any, res: any) => {
        res.status(200).json({ data: [], pagination: {} });
      });

      await request(app).get('/discover/feed').expect(200);

      // Verifica se o middleware foi chamado com configuração específica
      expect(smartCacheMiddleware).toHaveBeenCalledWith('discover', {
        varyBy: ['userId', 'page', 'take', 'lg'],
        ttl: 300
      });
    });

    it('deve aplicar configuração de cache específica para IA', async () => {
      const { smartCacheMiddleware } = require('@/middlewares/smartCache');
      
      mockedController.getIA.mockImplementation((req: any, res: any) => {
        res.status(200).json({ data: [], pagination: {} });
      });

      await request(app).get('/discover/ia').expect(200);

      // Verifica se o middleware foi chamado com configuração específica
      expect(smartCacheMiddleware).toHaveBeenCalledWith('discover', {
        varyBy: ['userId'],
        ttl: 600
      });
    });
  });

  describe('Testes de Parâmetros', () => {
    it('deve tratar parâmetros de paginação corretamente', async () => {
      mockedController.getRecent.mockImplementation((req: any, res: any) => {
        res.status(200).json({ data: [], pagination: {} });
      });

      await request(app)
        .get('/discover/recents?page=2&take=5&lg=en')
        .expect(200);

      expect(mockedController.getRecent).toHaveBeenCalled();
    });

    it('deve tratar parâmetros de idioma corretamente', async () => {
      mockedController.getMostViewed.mockImplementation((req: any, res: any) => {
        res.status(200).json({ data: [], pagination: {} });
      });

      await request(app)
        .get('/discover/views?lg=pt-BR')
        .expect(200);

      expect(mockedController.getMostViewed).toHaveBeenCalled();
    });
  });

  describe('Testes de Erro', () => {
    it('deve tratar erros de handler corretamente', async () => {
      mockedHandler.getRecent.mockRejectedValue(new Error('Erro no banco'));
      mockedController.getRecent.mockImplementation(async (req: any, res: any) => {
        try {
          await discoverHandler.getRecent('pt', 1, 10);
        } catch (error: any) {
          res.status(500).json({ error: error.message });
        }
      });

      const response = await request(app)
        .get('/discover/recents')
        .expect(500);

      expect(response.body).toEqual({ error: 'Erro no banco' });
    });

    it('deve tratar timeout de requests', async () => {
      // Simula timeout
      mockedHandler.getRecent.mockImplementation(() => {
        return new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Timeout')), 100);
        });
      });

      mockedController.getRecent.mockImplementation(async (req: any, res: any) => {
        try {
          await discoverHandler.getRecent('pt', 1, 10);
        } catch (error: any) {
          res.status(408).json({ error: 'Request timeout' });
        }
      });

      const response = await request(app)
        .get('/discover/recents')
        .expect(408);

      expect(response.body).toEqual({ error: 'Request timeout' });
    });
  });
}); 